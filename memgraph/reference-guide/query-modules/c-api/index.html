<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.70">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Memgraph Docs Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Memgraph Docs Blog Atom Feed">
<link rel="search" type="application/opensearchdescription+xml" title="Memgraph Docs" href="/opensearch.xml">
<script src="https://docs.memgraph.com/js/load-analytics.js"></script><title data-react-helmet="true">Query modules C API | Memgraph Docs</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Query modules C API | Memgraph Docs"><meta data-react-helmet="true" name="description" content="This is the API documentation for mg_procedure.h which contains declarations of all functions that can be used to implement a query module procedure. The source file can be found in the Memgraph installation directory, under include/memgraph. On the standard Debian installation, this will be under /usr/include/memgraph."><meta data-react-helmet="true" property="og:description" content="This is the API documentation for mg_procedure.h which contains declarations of all functions that can be used to implement a query module procedure. The source file can be found in the Memgraph installation directory, under include/memgraph. On the standard Debian installation, this will be under /usr/include/memgraph."><meta data-react-helmet="true" property="og:url" content="https://docs.memgraph.com/memgraph/reference-guide/query-modules/c-api"><link data-react-helmet="true" rel="shortcut icon" href="/img/social-logo-round-corners.png"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link data-react-helmet="true" rel="canonical" href="https://docs.memgraph.com/memgraph/reference-guide/query-modules/c-api"><link rel="stylesheet" href="/styles.0dc48699.css">
<link rel="preload" href="/styles.59fcf1e7.js" as="script">
<link rel="preload" href="/runtime~main.9d2c059a.js" as="script">
<link rel="preload" href="/main.79262d0f.js" as="script">
<link rel="preload" href="/1.87301906.js" as="script">
<link rel="preload" href="/2.51806c2b.js" as="script">
<link rel="preload" href="/105.007cf896.js" as="script">
<link rel="preload" href="/108.8571e3f8.js" as="script">
<link rel="preload" href="/935f2afb.0f6a0534.js" as="script">
<link rel="preload" href="/17896441.83e9fdd2.js" as="script">
<link rel="preload" href="/7974d505.9065b331.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_11B0">Skip to main content</button></nav><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img src="/img/social-logo-round-corners.png" alt="Memgraph Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/social-logo-round-corners.png" alt="Memgraph Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">Docs</strong></a><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/memgraph/overview">Memgraph DB</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/memgraph/getting-started">Getting started</a></li><li><a class="dropdown__link" href="/memgraph/getting-started/installation">Installation</a></li><li><a class="dropdown__link" href="/memgraph/database-functionalities">Database functionalities</a></li><li><a class="dropdown__link" href="/memgraph/getting-started/connecting-applications">Building applications</a></li><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/memgraph/reference-guide">Reference guide</a></li></ul></div><a class="navbar__item navbar__link" href="/memgraph-lab/">Memgraph Lab</a><a class="navbar__item navbar__link" href="/memgraph-cloud/">Memgraph Cloud</a><div class="navbar__item dropdown dropdown--hoverable dropdown--left"><a class="navbar__item navbar__link" href="/cypher-manual/">Cypher manual</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/cypher-manual/">Overview</a></li><li><a class="dropdown__link" href="/cypher-manual/functions">Functions</a></li><li><a class="dropdown__link" href="/cypher-manual/clauses">Clauses</a></li><li><a class="dropdown__link" href="/cypher-manual/other-features">Other features</a></li><li><a class="dropdown__link" href="/cypher-manual/differences">Differences</a></li></ul></div></div><div class="navbar__items navbar__items--right"><a href="https://github.com/memgraph" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2N3Q"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_3NWk">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_3NWk">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span></button></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/social-logo-round-corners.png" alt="Memgraph Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/social-logo-round-corners.png" alt="Memgraph Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">Docs</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a aria-current="page" class="menu__link menu__link--sublist navbar__link--active" role="button" href="/memgraph/overview">Memgraph DB</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/memgraph/getting-started">Getting started</a></li><li class="menu__list-item"><a class="menu__link" href="/memgraph/getting-started/installation">Installation</a></li><li class="menu__list-item"><a class="menu__link" href="/memgraph/database-functionalities">Database functionalities</a></li><li class="menu__list-item"><a class="menu__link" href="/memgraph/getting-started/connecting-applications">Building applications</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active" href="/memgraph/reference-guide">Reference guide</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/memgraph-lab/">Memgraph Lab</a></li><li class="menu__list-item"><a class="menu__link" href="/memgraph-cloud/">Memgraph Cloud</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" role="button" href="/cypher-manual/">Cypher manual</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/cypher-manual/">Overview</a></li><li class="menu__list-item"><a class="menu__link" href="/cypher-manual/functions">Functions</a></li><li class="menu__list-item"><a class="menu__link" href="/cypher-manual/clauses">Clauses</a></li><li class="menu__list-item"><a class="menu__link" href="/cypher-manual/other-features">Other features</a></li><li class="menu__list-item"><a class="menu__link" href="/cypher-manual/differences">Differences</a></li></ul></li><li class="menu__list-item"><a href="https://github.com/memgraph" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_vMrn"><div class="docSidebarContainer_3Ak5" role="complementary"><div class="sidebar_3gvy"><div class="menu menu--responsive thin-scrollbar menu_1yIk"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_1CUI" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/memgraph/overview">Overview</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Getting started</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/getting-started">Where to start?</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Installation</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/getting-started/installation">Installation overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/getting-started/installation/docker-installation">Docker (Windows, Linux, macOS)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/getting-started/installation/debian-installation">Debian GNU/Linux</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/getting-started/installation/rpm-installation">RPM package</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Querying the database</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/getting-started/querying/querying">Querying the database</a></li><li class="menu__list-item"><a href="https://docs.memgraph.com/memgraph-lab" target="_blank" rel="noreferrer noopener" class="menu__link" tabindex="-1">Memgraph Lab</a></li><li class="menu__list-item"><a href="https://playground.memgraph.com/" target="_blank" rel="noreferrer noopener" class="menu__link" tabindex="-1">Memgraph Playground</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Building applications</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/getting-started/connecting-applications">Building applications</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/getting-started/connecting-applications/python">Python</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/getting-started/connecting-applications/rust">Rust</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/getting-started/connecting-applications/c-sharp">C#</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/getting-started/connecting-applications/java">Java</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/getting-started/connecting-applications/go">Go</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/getting-started/connecting-applications/javascript">JavaScript</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Tutorials</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/tutorials/tutorials">Tutorials overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/tutorials/analyzing-ted-talks">Analyzing TED Talks</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/tutorials/backpacking-through-europe">Backpacking through Europe</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/tutorials/exploring-the-european-road-network">Exploring the European road network</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/tutorials/football-transfers">Football transfers</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/tutorials/graphing-the-premier-league">Graphing the Premier League</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/tutorials/marvel-universe">Marvel Comic Universe social network</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/tutorials/movie-recommendation">Movie recommendation system</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/tutorials/social-network-analysis">Social network analysis with NetworkX</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/tutorials/understanding-music-with-modules">Understanding music (with query modules)</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Database functionalities</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/database-functionalities">Database functionalities overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/database-functionalities/import-data">Import data</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/database-functionalities/inspecting-queries">Inspecting queries</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/database-functionalities/profiling-queries">Profiling queries</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/database-functionalities/tensorflow-setup">TensorFlow Op</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/reference-guide/backup">Backup</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Enforcing constraints</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/database-functionalities/constraints/existence-constraint">Existence constraint</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/database-functionalities/constraints/uniqueness-constraint">Uniqueness constraint</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Query modules</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/database-functionalities/query-modules/built-in-query-modules">Built-in query modules</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/database-functionalities/query-modules/load-call-query-modules">Load and call custom query modules</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/database-functionalities/query-modules/implement-query-modules">Implement custom query modules</a></li></ul></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/database-functionalities/manage-user-privileges">User privileges (Enterprise)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/database-functionalities/manage-users-using-ldap">Authentication and authorization (Enterprise)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/database-functionalities/replication">Replication (Enterprise)</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Reference guide</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/reference-guide">Reference guide overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/reference-guide/configuration">Memgraph configuration</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/reference-guide/indexing">Indexing</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/reference-guide/graph-algorithms">Graph algorithms</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/reference-guide/tensorflow">TensorFlow Op</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/reference-guide/backup">Backup</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Query modules</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/reference-guide/query-modules">Query modules</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/memgraph/reference-guide/query-modules/c-api">C API</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/reference-guide/query-modules/python-api">Python API</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">NetworkX</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/reference-guide/networkx">NetworkX overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/reference-guide/networkx/graph-analyzer">Graph Analyzer</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/reference-guide/networkx/nxalg">NetworkX Algorithms</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/reference-guide/networkx/wcc">Weakly Connected Components</a></li></ul></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/reference-guide/security">Security (Enterprise)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/reference-guide/auth-module">Auth module (Enterprise)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/reference-guide/ldap-security">LDAP Security (Enterprise)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/reference-guide/audit-log">Audit log (Enterprise)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/memgraph/reference-guide/replication">Replication (Enterprise)</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Concepts</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/concepts">Concepts overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/concepts/storage">Storage</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/concepts/graph-algorithms">Graph algorithms</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/concepts/indexing">Indexing</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/concepts/replication">Replication</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Drivers</a><ul class="menu__list"><li class="menu__list-item"><a href="https://github.com/memgraph/mgclient" target="_blank" rel="noreferrer noopener" class="menu__link" tabindex="-1">C/C++</a></li><li class="menu__list-item"><a href="https://github.com/memgraph/mgconsole" target="_blank" rel="noreferrer noopener" class="menu__link" tabindex="-1">CLI Console</a></li><li class="menu__list-item"><a href="https://github.com/memgraph/pymgclient" target="_blank" rel="noreferrer noopener" class="menu__link" tabindex="-1">Python</a></li><li class="menu__list-item"><a href="https://github.com/memgraph/rsmgclient" target="_blank" rel="noreferrer noopener" class="menu__link" tabindex="-1">Rust</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/memgraph/upcoming-features">Upcoming features</a></li><li class="menu__list-item"><a class="menu__link" href="/memgraph/changelog">Changelog</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Getting help</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/getting-help/getting-help">Getting help</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/memgraph/getting-help/faq">FAQ</a></li></ul></li></ul></div></div></div><main class="docMainContainer_2iGs"><div class="container padding-vert--lg docItemWrapper_1bxp"><div class="row"><div class="col docItemCol_U38p"><div class="docItemContainer_a7m4"><article><header><h1 class="docTitle_Oumm">Query modules C API</h1></header><div class="markdown"><p>This is the API documentation for <code>mg_procedure.h</code> which contains declarations of all functions that can be used to implement a query module procedure. The source file can be found in the Memgraph installation directory, under <code>include/memgraph</code>. On the standard Debian installation, this will be under <code>/usr/include/memgraph</code>. </p><div class="admonition admonition-caution alert alert--warning"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>caution</h5></div><div class="admonition-content"><p><strong>NOTE:</strong> This part of the documentation is still under development. An updated version will soon be available.</p></div></div><h2 id="classes">Classes</h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td>struct</td><td><strong>mgp_label</strong> <br>Label of a vertex.</td></tr><tr><td>struct</td><td><strong>mgp_edge_type</strong> <br>Type of an edge.</td></tr><tr><td>struct</td><td><strong>mgp_property</strong> <br>Reference to a named property value.</td></tr><tr><td>struct</td><td><strong>mgp_vertex_id</strong> <br>ID of a vertex; valid during a single query execution.</td></tr><tr><td>struct</td><td><strong>mgp_edge_id</strong> <br>ID of an edge; valid during a single query execution.</td></tr></tbody></table><h2 id="types">Types</h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td>enum</td><td><strong><a href="#enum-mgp_value_type">mgp_value_type</a></strong> { MGP_VALUE_TYPE_NULL, MGP_VALUE_TYPE_BOOL, MGP_VALUE_TYPE_INT, MGP_VALUE_TYPE_DOUBLE, MGP_VALUE_TYPE_STRING, MGP_VALUE_TYPE_LIST, MGP_VALUE_TYPE_MAP, MGP_VALUE_TYPE_VERTEX, MGP_VALUE_TYPE_EDGE, MGP_VALUE_TYPE_PATH }<br>All available types that can be stored in a mgp_value.</td></tr><tr><td>typedef void(<em>)(const struct mgp_list </em>, const struct mgp_graph <em>, struct mgp_result </em>, struct mgp_memory *)</td><td><strong><a href="#typedef-mgp_proc_cb">mgp_proc_cb</a></strong> <br>Entry-point for a query module procedure, invoked through openCypher.</td></tr></tbody></table><h2 id="functions">Functions</h2><table><thead><tr><th></th><th>Name</th></tr></thead><tbody><tr><td>void *</td><td><strong><a href="#function-mgp_alloc">mgp_alloc</a></strong>(struct mgp_memory * memory, size_t size_in_bytes) <br>Allocate a block of memory with given size in bytes.</td></tr><tr><td>void *</td><td><strong><a href="#function-mgp_aligned_alloc">mgp_aligned_alloc</a></strong>(struct mgp_memory * memory, size_t size_in_bytes, size_t alignment) <br>Allocate an aligned block of memory with given size in bytes.</td></tr><tr><td>void</td><td><strong><a href="#function-mgp_free">mgp_free</a></strong>(struct mgp_memory <em> memory, void </em> ptr) <br>Deallocate an allocation from mgp_alloc or mgp_aligned_alloc.</td></tr><tr><td>void</td><td><strong><a href="#function-mgp_value_destroy">mgp_value_destroy</a></strong>(struct mgp_value * val) <br>Free the memory used by the given mgp_value instance.</td></tr><tr><td>struct mgp_value *</td><td><strong><a href="#function-mgp_value_make_null">mgp_value_make_null</a></strong>(struct mgp_memory * memory) <br>Construct a value representing <code>null</code> in openCypher.</td></tr><tr><td>struct mgp_value *</td><td><strong><a href="#function-mgp_value_make_bool">mgp_value_make_bool</a></strong>(int val, struct mgp_memory * memory) <br>Construct a boolean value.</td></tr><tr><td>struct mgp_value *</td><td><strong><a href="#function-mgp_value_make_int">mgp_value_make_int</a></strong>(int64_t val, struct mgp_memory * memory) <br>Construct an integer value.</td></tr><tr><td>struct mgp_value *</td><td><strong><a href="#function-mgp_value_make_double">mgp_value_make_double</a></strong>(double val, struct mgp_memory * memory) <br>Construct a double floating point value.</td></tr><tr><td>struct mgp_value *</td><td><strong><a href="#function-mgp_value_make_string">mgp_value_make_string</a></strong>(const char <em> val, struct mgp_memory </em> memory) <br>Construct a character string value from a NULL terminated string.</td></tr><tr><td>struct mgp_value *</td><td><strong><a href="#function-mgp_value_make_list">mgp_value_make_list</a></strong>(struct mgp_list * val) <br>Create a mgp_value storing a mgp_list.</td></tr><tr><td>struct mgp_value *</td><td><strong><a href="#function-mgp_value_make_map">mgp_value_make_map</a></strong>(struct mgp_map * val) <br>Create a mgp_value storing a mgp_map.</td></tr><tr><td>struct mgp_value *</td><td><strong><a href="#function-mgp_value_make_vertex">mgp_value_make_vertex</a></strong>(struct mgp_vertex * val) <br>Create a mgp_value storing a mgp_vertex.</td></tr><tr><td>struct mgp_value *</td><td><strong><a href="#function-mgp_value_make_edge">mgp_value_make_edge</a></strong>(struct mgp_edge * val) <br>Create a mgp_value storing a mgp_edge.</td></tr><tr><td>struct mgp_value *</td><td><strong><a href="#function-mgp_value_make_path">mgp_value_make_path</a></strong>(struct mgp_path * val) <br>Create a mgp_value storing a mgp_path.</td></tr><tr><td>enum <a href="#enum-mgp_value_type">mgp_value_type</a></td><td><strong><a href="#function-mgp_value_get_type">mgp_value_get_type</a></strong>(const struct mgp_value * val) <br>Return the type of the value contained in mgp_value.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_value_is_null">mgp_value_is_null</a></strong>(const struct mgp_value * val) <br>Return non-zero if the given mgp_value represents <code>null</code>.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_value_is_bool">mgp_value_is_bool</a></strong>(const struct mgp_value * val) <br>Return non-zero if the given mgp_value stores a boolean.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_value_is_int">mgp_value_is_int</a></strong>(const struct mgp_value * val) <br>Return non-zero if the given mgp_value stores an integer.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_value_is_double">mgp_value_is_double</a></strong>(const struct mgp_value * val) <br>Return non-zero if the given mgp_value stores a double floating-point.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_value_is_string">mgp_value_is_string</a></strong>(const struct mgp_value * val) <br>Return non-zero if the given mgp_value stores a character string.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_value_is_list">mgp_value_is_list</a></strong>(const struct mgp_value * val) <br>Return non-zero if the given mgp_value stores a list of values.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_value_is_map">mgp_value_is_map</a></strong>(const struct mgp_value * val) <br>Return non-zero if the given mgp_value stores a map of values.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_value_is_vertex">mgp_value_is_vertex</a></strong>(const struct mgp_value * val) <br>Return non-zero if the given mgp_value stores a vertex.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_value_is_edge">mgp_value_is_edge</a></strong>(const struct mgp_value * val) <br>Return non-zero if the given mgp_value stores an edge.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_value_is_path">mgp_value_is_path</a></strong>(const struct mgp_value * val) <br>Return non-zero if the given mgp_value stores a path.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_value_get_bool">mgp_value_get_bool</a></strong>(const struct mgp_value * val) <br>Return the contained boolean value.</td></tr><tr><td>int64_t</td><td><strong><a href="#function-mgp_value_get_int">mgp_value_get_int</a></strong>(const struct mgp_value * val) <br>Return the contained integer.</td></tr><tr><td>double</td><td><strong><a href="#function-mgp_value_get_double">mgp_value_get_double</a></strong>(const struct mgp_value * val) <br>Return the contained double floating-point.</td></tr><tr><td>const char *</td><td><strong><a href="#function-mgp_value_get_string">mgp_value_get_string</a></strong>(const struct mgp_value * val) <br>Return the contained character string.</td></tr><tr><td>const struct mgp_list *</td><td><strong><a href="#function-mgp_value_get_list">mgp_value_get_list</a></strong>(const struct mgp_value * val) <br>Return the contained list of values.</td></tr><tr><td>const struct mgp_map *</td><td><strong><a href="#function-mgp_value_get_map">mgp_value_get_map</a></strong>(const struct mgp_value * val) <br>Return the contained map of values.</td></tr><tr><td>const struct mgp_vertex *</td><td><strong><a href="#function-mgp_value_get_vertex">mgp_value_get_vertex</a></strong>(const struct mgp_value * val) <br>Return the contained vertex.</td></tr><tr><td>const struct mgp_edge *</td><td><strong><a href="#function-mgp_value_get_edge">mgp_value_get_edge</a></strong>(const struct mgp_value * val) <br>Return the contained edge.</td></tr><tr><td>const struct mgp_path *</td><td><strong><a href="#function-mgp_value_get_path">mgp_value_get_path</a></strong>(const struct mgp_value * val) <br>Return the contained path.</td></tr><tr><td>struct mgp_list *</td><td><strong><a href="#function-mgp_list_make_empty">mgp_list_make_empty</a></strong>(size_t capacity, struct mgp_memory * memory) <br>Create an empty list with given capacity.</td></tr><tr><td>void</td><td><strong><a href="#function-mgp_list_destroy">mgp_list_destroy</a></strong>(struct mgp_list * list) <br>Free the memory used by the given mgp_list and contained elements.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_list_append">mgp_list_append</a></strong>(struct mgp_list <em> list, const struct mgp_value </em> val) <br>Append a copy of mgp_value to mgp_list if capacity allows.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_list_append_extend">mgp_list_append_extend</a></strong>(struct mgp_list <em> list, const struct mgp_value </em> val) <br>Append a copy of mgp_value to mgp_list increasing capacity if needed.</td></tr><tr><td>size_t</td><td><strong><a href="#function-mgp_list_size">mgp_list_size</a></strong>(const struct mgp_list * list) <br>Return the number of elements stored in mgp_list.</td></tr><tr><td>size_t</td><td><strong><a href="#function-mgp_list_capacity">mgp_list_capacity</a></strong>(const struct mgp_list * list) <br>Return the total number of elements for which there&#x27;s already allocated memory in mgp_list.</td></tr><tr><td>const struct mgp_value *</td><td><strong><a href="#function-mgp_list_at">mgp_list_at</a></strong>(const struct mgp_list * list, size_t index) <br>Return the element in mgp_list at given position.</td></tr><tr><td>struct mgp_map *</td><td><strong><a href="#function-mgp_map_make_empty">mgp_map_make_empty</a></strong>(struct mgp_memory * memory) <br>Create an empty map of character strings to mgp_value instances.</td></tr><tr><td>void</td><td><strong><a href="#function-mgp_map_destroy">mgp_map_destroy</a></strong>(struct mgp_map * map) <br>Free the memory used by the given mgp_map and contained items.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_map_insert">mgp_map_insert</a></strong>(struct mgp_map <em> map, const char </em> key, const struct mgp_value * value) <br>Insert a new mapping from a NULL terminated character string to a value.</td></tr><tr><td>size_t</td><td><strong><a href="#function-mgp_map_size">mgp_map_size</a></strong>(const struct mgp_map * map) <br>Return the number of items stored in mgp_map.</td></tr><tr><td>const struct mgp_value *</td><td><strong><a href="#function-mgp_map_at">mgp_map_at</a></strong>(const struct mgp_map <em> map, const char </em> key) <br>Return the mapped mgp_value to the given character string.</td></tr><tr><td>const char *</td><td><strong><a href="#function-mgp_map_item_key">mgp_map_item_key</a></strong>(const struct mgp_map_item * item) <br>Get the key of the mapped item.</td></tr><tr><td>const struct mgp_value *</td><td><strong><a href="#function-mgp_map_item_value">mgp_map_item_value</a></strong>(const struct mgp_map_item * item) <br>Get the value of the mapped item.</td></tr><tr><td>struct mgp_map_items_iterator *</td><td><strong><a href="#function-mgp_map_iter_items">mgp_map_iter_items</a></strong>(const struct mgp_map <em> map, struct mgp_memory </em> memory) <br>Start iterating over items contained in the given map.</td></tr><tr><td>void</td><td><strong><a href="#function-mgp_map_items_iterator_destroy">mgp_map_items_iterator_destroy</a></strong>(struct mgp_map_items_iterator * it) <br>Deallocate memory used by mgp_map_items_iterator.</td></tr><tr><td>const struct mgp_map_item *</td><td><strong><a href="#function-mgp_map_items_iterator_get">mgp_map_items_iterator_get</a></strong>(const struct mgp_map_items_iterator * it) <br>Get the current item pointed to by the iterator.</td></tr><tr><td>const struct mgp_map_item *</td><td><strong><a href="#function-mgp_map_items_iterator_next">mgp_map_items_iterator_next</a></strong>(struct mgp_map_items_iterator * it) <br>Advance the iterator to the next item stored in map and return it.</td></tr><tr><td>struct mgp_path *</td><td><strong><a href="#function-mgp_path_make_with_start">mgp_path_make_with_start</a></strong>(const struct mgp_vertex <em> vertex, struct mgp_memory </em> memory) <br>Create a path with the copy of the given starting vertex.</td></tr><tr><td>struct mgp_path *</td><td><strong><a href="#function-mgp_path_copy">mgp_path_copy</a></strong>(const struct mgp_path <em> path, struct mgp_memory </em> memory) <br>Copy a mgp_path.</td></tr><tr><td>void</td><td><strong><a href="#function-mgp_path_destroy">mgp_path_destroy</a></strong>(struct mgp_path * path) <br>Free the memory used by the given mgp_path and contained vertices and edges.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_path_expand">mgp_path_expand</a></strong>(struct mgp_path <em> path, const struct mgp_edge </em> edge) <br>Append an edge continuing from the last vertex on the path.</td></tr><tr><td>size_t</td><td><strong><a href="#function-mgp_path_size">mgp_path_size</a></strong>(const struct mgp_path * path) <br>Return the number of edges in a mgp_path.</td></tr><tr><td>const struct mgp_vertex *</td><td><strong><a href="#function-mgp_path_vertex_at">mgp_path_vertex_at</a></strong>(const struct mgp_path * path, size_t index) <br>Return the vertex from a path at given index.</td></tr><tr><td>const struct mgp_edge *</td><td><strong><a href="#function-mgp_path_edge_at">mgp_path_edge_at</a></strong>(const struct mgp_path * path, size_t index) <br>Return the edge from a path at given index.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_path_equal">mgp_path_equal</a></strong>(const struct mgp_path <em> p1, const struct mgp_path </em> p2) <br>Return non-zero if given paths are equal, otherwise 0.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_result_set_error_msg">mgp_result_set_error_msg</a></strong>(struct mgp_result <em> res, const char </em> error_msg) <br>Set the error as the result of the procedure.</td></tr><tr><td>struct mgp_result_record *</td><td><strong><a href="#function-mgp_result_new_record">mgp_result_new_record</a></strong>(struct mgp_result * res) <br>Create a new record for results.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_result_record_insert">mgp_result_record_insert</a></strong>(struct mgp_result_record <em> record, const char </em> field_name, const struct mgp_value * val) <br>Assign a value to a field in the given record.</td></tr><tr><td>void</td><td><strong><a href="#function-mgp_properties_iterator_destroy">mgp_properties_iterator_destroy</a></strong>(struct mgp_properties_iterator * it) <br>Free the memory used by a mgp_properties_iterator.</td></tr><tr><td>const struct mgp_property *</td><td><strong><a href="#function-mgp_properties_iterator_get">mgp_properties_iterator_get</a></strong>(const struct mgp_properties_iterator * it) <br>Get the current property pointed to by the iterator.</td></tr><tr><td>const struct mgp_property *</td><td><strong><a href="#function-mgp_properties_iterator_next">mgp_properties_iterator_next</a></strong>(struct mgp_properties_iterator * it) <br>Advance the iterator to the next property and return it.</td></tr><tr><td>void</td><td><strong><a href="#function-mgp_edges_iterator_destroy">mgp_edges_iterator_destroy</a></strong>(struct mgp_edges_iterator * it) <br>Free the memory used by a mgp_edges_iterator.</td></tr><tr><td>struct mgp_vertex_id</td><td><strong><a href="#function-mgp_vertex_get_id">mgp_vertex_get_id</a></strong>(const struct mgp_vertex * v) <br>Get the ID of given vertex.</td></tr><tr><td>struct mgp_vertex *</td><td><strong><a href="#function-mgp_vertex_copy">mgp_vertex_copy</a></strong>(const struct mgp_vertex <em> v, struct mgp_memory </em> memory) <br>Copy a mgp_vertex.</td></tr><tr><td>void</td><td><strong><a href="#function-mgp_vertex_destroy">mgp_vertex_destroy</a></strong>(struct mgp_vertex * v) <br>Free the memory used by a mgp_vertex.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_vertex_equal">mgp_vertex_equal</a></strong>(const struct mgp_vertex <em> v1, const struct mgp_vertex </em> v2) <br>Return non-zero if given vertices are equal, otherwise 0.</td></tr><tr><td>size_t</td><td><strong><a href="#function-mgp_vertex_labels_count">mgp_vertex_labels_count</a></strong>(const struct mgp_vertex * v) <br>Return the number of labels a given vertex has.</td></tr><tr><td>struct mgp_label</td><td><strong><a href="#function-mgp_vertex_label_at">mgp_vertex_label_at</a></strong>(const struct mgp_vertex * v, size_t index) <br>Return mgp_label in mgp_vertex at given index.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_vertex_has_label">mgp_vertex_has_label</a></strong>(const struct mgp_vertex * v, struct mgp_label label) <br>Return non-zero if the given vertex has the given label.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_vertex_has_label_named">mgp_vertex_has_label_named</a></strong>(const struct mgp_vertex <em> v, const char </em> label_name) <br>Return non-zero if the given vertex has a label with given name.</td></tr><tr><td>struct mgp_value *</td><td><strong><a href="#function-mgp_vertex_get_property">mgp_vertex_get_property</a></strong>(const struct mgp_vertex <em> v, const char </em> property_name, struct mgp_memory * memory) <br>Get a copy of a vertex property mapped to a given name.</td></tr><tr><td>struct mgp_properties_iterator *</td><td><strong><a href="#function-mgp_vertex_iter_properties">mgp_vertex_iter_properties</a></strong>(const struct mgp_vertex <em> v, struct mgp_memory </em> memory) <br>Start iterating over properties stored in the given vertex.</td></tr><tr><td>struct mgp_edges_iterator *</td><td><strong><a href="#function-mgp_vertex_iter_in_edges">mgp_vertex_iter_in_edges</a></strong>(const struct mgp_vertex <em> v, struct mgp_memory </em> memory) <br>Start iterating over inbound edges of the given vertex.</td></tr><tr><td>struct mgp_edges_iterator *</td><td><strong><a href="#function-mgp_vertex_iter_out_edges">mgp_vertex_iter_out_edges</a></strong>(const struct mgp_vertex <em> v, struct mgp_memory </em> memory) <br>Start iterating over outbound edges of the given vertex.</td></tr><tr><td>const struct mgp_edge *</td><td><strong><a href="#function-mgp_edges_iterator_get">mgp_edges_iterator_get</a></strong>(const struct mgp_edges_iterator * it) <br>Get the current edge pointed to by the iterator.</td></tr><tr><td>const struct mgp_edge *</td><td><strong><a href="#function-mgp_edges_iterator_next">mgp_edges_iterator_next</a></strong>(struct mgp_edges_iterator * it) <br>Advance the iterator to the next edge and return it.</td></tr><tr><td>struct mgp_edge_id</td><td><strong><a href="#function-mgp_edge_get_id">mgp_edge_get_id</a></strong>(const struct mgp_edge * e) <br>Get the ID of given edge.</td></tr><tr><td>struct mgp_edge *</td><td><strong><a href="#function-mgp_edge_copy">mgp_edge_copy</a></strong>(const struct mgp_edge <em> e, struct mgp_memory </em> memory) <br>Copy a mgp_edge.</td></tr><tr><td>void</td><td><strong><a href="#function-mgp_edge_destroy">mgp_edge_destroy</a></strong>(struct mgp_edge * e) <br>Free the memory used by a mgp_edge.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_edge_equal">mgp_edge_equal</a></strong>(const struct mgp_edge <em> e1, const struct mgp_edge </em> e2) <br>Return non-zero if given edges are equal, otherwise 0.</td></tr><tr><td>struct mgp_edge_type</td><td><strong><a href="#function-mgp_edge_get_type">mgp_edge_get_type</a></strong>(const struct mgp_edge * e) <br>Return the type of the given edge.</td></tr><tr><td>const struct mgp_vertex *</td><td><strong><a href="#function-mgp_edge_get_from">mgp_edge_get_from</a></strong>(const struct mgp_edge * e) <br>Return the source vertex of the given edge.</td></tr><tr><td>const struct mgp_vertex *</td><td><strong><a href="#function-mgp_edge_get_to">mgp_edge_get_to</a></strong>(const struct mgp_edge * e) <br>Return the destination vertex of the given edge.</td></tr><tr><td>struct mgp_value *</td><td><strong><a href="#function-mgp_edge_get_property">mgp_edge_get_property</a></strong>(const struct mgp_edge <em> e, const char </em> property_name, struct mgp_memory * memory) <br>Get a copy of a edge property mapped to a given name.</td></tr><tr><td>struct mgp_properties_iterator *</td><td><strong><a href="#function-mgp_edge_iter_properties">mgp_edge_iter_properties</a></strong>(const struct mgp_edge <em> e, struct mgp_memory </em> memory) <br>Start iterating over properties stored in the given edge.</td></tr><tr><td>struct mgp_vertex *</td><td><strong><a href="#function-mgp_graph_get_vertex_by_id">mgp_graph_get_vertex_by_id</a></strong>(const struct mgp_graph <em> g, struct mgp_vertex_id id, struct mgp_memory </em> memory) <br>Return the vertex corresponding to given ID.</td></tr><tr><td>void</td><td><strong><a href="#function-mgp_vertices_iterator_destroy">mgp_vertices_iterator_destroy</a></strong>(struct mgp_vertices_iterator * it) <br>Free the memory used by a mgp_vertices_iterator.</td></tr><tr><td>struct mgp_vertices_iterator *</td><td><strong><a href="#function-mgp_graph_iter_vertices">mgp_graph_iter_vertices</a></strong>(const struct mgp_graph <em> g, struct mgp_memory </em> memory) <br>Start iterating over vertices of the given graph.</td></tr><tr><td>const struct mgp_vertex *</td><td><strong><a href="#function-mgp_vertices_iterator_get">mgp_vertices_iterator_get</a></strong>(const struct mgp_vertices_iterator * it) <br>Get the current vertex pointed to by the iterator.</td></tr><tr><td>const struct mgp_vertex *</td><td><strong><a href="#function-mgp_vertices_iterator_next">mgp_vertices_iterator_next</a></strong>(struct mgp_vertices_iterator * it) <br>Advance the iterator to the next vertex and return it.</td></tr><tr><td>const struct mgp_type *</td><td><strong><a href="#function-mgp_type_any">mgp_type_any</a></strong>() <br>Get the type representing any value that isn&#x27;t <code>null</code>.</td></tr><tr><td>const struct mgp_type *</td><td><strong><a href="#function-mgp_type_bool">mgp_type_bool</a></strong>() <br>Get the type representing boolean values.</td></tr><tr><td>const struct mgp_type *</td><td><strong><a href="#function-mgp_type_string">mgp_type_string</a></strong>() <br>Get the type representing character string values.</td></tr><tr><td>const struct mgp_type *</td><td><strong><a href="#function-mgp_type_int">mgp_type_int</a></strong>() <br>Get the type representing integer values.</td></tr><tr><td>const struct mgp_type *</td><td><strong><a href="#function-mgp_type_float">mgp_type_float</a></strong>() <br>Get the type representing floating-point values.</td></tr><tr><td>const struct mgp_type *</td><td><strong><a href="#function-mgp_type_number">mgp_type_number</a></strong>() <br>Get the type representing any number value.</td></tr><tr><td>const struct mgp_type *</td><td><strong><a href="#function-mgp_type_map">mgp_type_map</a></strong>() <br>Get the type representing map values.</td></tr><tr><td>const struct mgp_type *</td><td><strong><a href="#function-mgp_type_node">mgp_type_node</a></strong>() <br>Get the type representing graph node values.</td></tr><tr><td>const struct mgp_type *</td><td><strong><a href="#function-mgp_type_relationship">mgp_type_relationship</a></strong>() <br>Get the type representing graph relationship values.</td></tr><tr><td>const struct mgp_type *</td><td><strong><a href="#function-mgp_type_path">mgp_type_path</a></strong>() <br>Get the type representing a graph path (walk) from one node to another.</td></tr><tr><td>const struct mgp_type *</td><td><strong><a href="#function-mgp_type_list">mgp_type_list</a></strong>(const struct mgp_type * element_type) <br>Build a type representing a list of values of given <code>element_type</code>.</td></tr><tr><td>const struct mgp_type *</td><td><strong><a href="#function-mgp_type_nullable">mgp_type_nullable</a></strong>(const struct mgp_type * type) <br>Build a type representing either a <code>null</code> value or a value of given <code>type</code>.</td></tr><tr><td>struct mgp_proc *</td><td><strong><a href="#function-mgp_module_add_read_procedure">mgp_module_add_read_procedure</a></strong>(struct mgp_module <em> module, const char </em> name, <a href="#typedef-mgp_proc_cb">mgp_proc_cb</a> cb) <br>Register a read-only procedure with a module.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_proc_add_arg">mgp_proc_add_arg</a></strong>(struct mgp_proc <em> proc, const char </em> name, const struct mgp_type * type) <br>Add a required argument to a procedure.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_proc_add_opt_arg">mgp_proc_add_opt_arg</a></strong>(struct mgp_proc <em> proc, const char </em> name, const struct mgp_type <em> type, const struct mgp_value </em> default_value) <br>Add an optional argument with a default value to a procedure.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_proc_add_result">mgp_proc_add_result</a></strong>(struct mgp_proc <em> proc, const char </em> name, const struct mgp_type * type) <br>Add a result field to a procedure.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_proc_add_deprecated_result">mgp_proc_add_deprecated_result</a></strong>(struct mgp_proc <em> proc, const char </em> name, const struct mgp_type * type) <br>Add a result field to a procedure and mark it as deprecated.</td></tr><tr><td>int</td><td><strong><a href="#function-mgp_must_abort">mgp_must_abort</a></strong>(const struct mgp_graph * graph) <br>Return non-zero if the currently executing procedure should abort as soon as possible.</td></tr></tbody></table><h2 id="types-documentation">Types Documentation</h2><h3 id="enum-mgp_value_type">enum mgp_value_type</h3><table><thead><tr><th>Enumerator</th></tr></thead><tbody><tr><td>MGP_VALUE_TYPE_NULL</td></tr><tr><td>MGP_VALUE_TYPE_BOOL</td></tr><tr><td>MGP_VALUE_TYPE_INT</td></tr><tr><td>MGP_VALUE_TYPE_DOUBLE</td></tr><tr><td>MGP_VALUE_TYPE_STRING</td></tr><tr><td>MGP_VALUE_TYPE_LIST</td></tr><tr><td>MGP_VALUE_TYPE_MAP</td></tr><tr><td>MGP_VALUE_TYPE_VERTEX</td></tr><tr><td>MGP_VALUE_TYPE_EDGE</td></tr><tr><td>MGP_VALUE_TYPE_PATH</td></tr></tbody></table><p>All available types that can be stored in a mgp_value. </p><h3 id="typedef-mgp_proc_cb">typedef mgp_proc_cb</h3><pre><code class="language-cpp">typedef void(* mgp_proc_cb) (const struct mgp_list *, const struct mgp_graph *, struct mgp_result *, struct mgp_memory *);
</code></pre><p>Entry-point for a query module procedure, invoked through openCypher.
Passed in arguments will not live longer than the callback&#x27;s execution. Therefore, you must not store them globally or use the passed in mgp_memory to allocate global resources. </p><h2 id="functions-documentation">Functions Documentation</h2><h3 id="function-mgp_alloc">function mgp_alloc</h3><pre><code class="language-cpp">void * mgp_alloc(
    struct mgp_memory * memory,
    size_t size_in_bytes
)
</code></pre><p>Allocate a block of memory with given size in bytes.
Unlike malloc, this function is not thread-safe. <code>size_in_bytes</code> must be greater than 0. The returned pointer must be freed with mgp_free. NULL is returned if unable to serve the requested allocation. </p><h3 id="function-mgp_aligned_alloc">function mgp_aligned_alloc</h3><pre><code class="language-cpp">void * mgp_aligned_alloc(
    struct mgp_memory * memory,
    size_t size_in_bytes,
    size_t alignment
)
</code></pre><p>Allocate an aligned block of memory with given size in bytes.
Unlike malloc and aligned_alloc, this function is not thread-safe. <code>size_in_bytes</code> must be greater than 0. <code>alignment</code> must be a power of 2 value. The returned pointer must be freed with mgp_free. NULL is returned if unable to serve the requested allocation. </p><h3 id="function-mgp_free">function mgp_free</h3><pre><code class="language-cpp">void mgp_free(
    struct mgp_memory * memory,
    void * ptr
)
</code></pre><p>Deallocate an allocation from mgp_alloc or mgp_aligned_alloc.
Unlike free, this function is not thread-safe. If <code>ptr</code> is NULL, this function does nothing. The behavior is undefined if <code>ptr</code> is not a value returned from a prior mgp_alloc or mgp_aligned_alloc call with the corresponding <code>memory</code>. </p><h3 id="function-mgp_value_destroy">function mgp_value_destroy</h3><pre><code class="language-cpp">void mgp_value_destroy(
    struct mgp_value * val
)
</code></pre><p>Free the memory used by the given mgp_value instance. </p><h3 id="function-mgp_value_make_null">function mgp_value_make_null</h3><pre><code class="language-cpp">struct mgp_value * mgp_value_make_null(
    struct mgp_memory * memory
)
</code></pre><p>Construct a value representing <code>null</code> in openCypher.
You need to free the instance through mgp_value_destroy. NULL is returned if unable to allocate a mgp_value. </p><h3 id="function-mgp_value_make_bool">function mgp_value_make_bool</h3><pre><code class="language-cpp">struct mgp_value * mgp_value_make_bool(
    int val,
    struct mgp_memory * memory
)
</code></pre><p>Construct a boolean value.
Non-zero values represent <code>true</code>, while zero represents <code>false</code>. You need to free the instance through mgp_value_destroy. NULL is returned if unable to allocate a mgp_value. </p><h3 id="function-mgp_value_make_int">function mgp_value_make_int</h3><pre><code class="language-cpp">struct mgp_value * mgp_value_make_int(
    int64_t val,
    struct mgp_memory * memory
)
</code></pre><p>Construct an integer value.
You need to free the instance through mgp_value_destroy. NULL is returned if unable to allocate a mgp_value. </p><h3 id="function-mgp_value_make_double">function mgp_value_make_double</h3><pre><code class="language-cpp">struct mgp_value * mgp_value_make_double(
    double val,
    struct mgp_memory * memory
)
</code></pre><p>Construct a double floating point value.
You need to free the instance through mgp_value_destroy. NULL is returned if unable to allocate a mgp_value. </p><h3 id="function-mgp_value_make_string">function mgp_value_make_string</h3><pre><code class="language-cpp">struct mgp_value * mgp_value_make_string(
    const char * val,
    struct mgp_memory * memory
)
</code></pre><p>Construct a character string value from a NULL terminated string.
You need to free the instance through mgp_value_destroy. NULL is returned if unable to allocate a mgp_value. </p><h3 id="function-mgp_value_make_list">function mgp_value_make_list</h3><pre><code class="language-cpp">struct mgp_value * mgp_value_make_list(
    struct mgp_list * val
)
</code></pre><p>Create a mgp_value storing a mgp_list.
You need to free the instance through mgp_value_destroy. The ownership of the list is given to the created mgp_value and destroying the mgp_value will destroy the mgp_list. Therefore, if a mgp_value is successfully created you must not call mgp_list_destroy on the given list. NULL is returned if unable to allocate a mgp_value. </p><h3 id="function-mgp_value_make_map">function mgp_value_make_map</h3><pre><code class="language-cpp">struct mgp_value * mgp_value_make_map(
    struct mgp_map * val
)
</code></pre><p>Create a mgp_value storing a mgp_map.
You need to free the instance through mgp_value_destroy. The ownership of the map is given to the created mgp_value and destroying the mgp_value will destroy the mgp_map. Therefore, if a mgp_value is successfully created you must not call mgp_map_destroy on the given map. NULL is returned if unable to allocate a mgp_value. </p><h3 id="function-mgp_value_make_vertex">function mgp_value_make_vertex</h3><pre><code class="language-cpp">struct mgp_value * mgp_value_make_vertex(
    struct mgp_vertex * val
)
</code></pre><p>Create a mgp_value storing a mgp_vertex.
You need to free the instance through mgp_value_destroy. The ownership of the vertex is given to the created mgp_value and destroying the mgp_value will destroy the mgp_vertex. Therefore, if a mgp_value is successfully created you must not call mgp_vertex_destroy on the given vertex. NULL is returned if unable to allocate a mgp_value. </p><h3 id="function-mgp_value_make_edge">function mgp_value_make_edge</h3><pre><code class="language-cpp">struct mgp_value * mgp_value_make_edge(
    struct mgp_edge * val
)
</code></pre><p>Create a mgp_value storing a mgp_edge.
You need to free the instance through mgp_value_destroy. The ownership of the edge is given to the created mgp_value and destroying the mgp_value will destroy the mgp_edge. Therefore, if a mgp_value is successfully created you must not call mgp_edge_destroy on the given edge. NULL is returned if unable to allocate a mgp_value. </p><h3 id="function-mgp_value_make_path">function mgp_value_make_path</h3><pre><code class="language-cpp">struct mgp_value * mgp_value_make_path(
    struct mgp_path * val
)
</code></pre><p>Create a mgp_value storing a mgp_path.
You need to free the instance through mgp_value_destroy. The ownership of the path is given to the created mgp_value and destroying the mgp_value will destroy the mgp_path. Therefore, if a mgp_value is successfully created you must not call mgp_path_destroy on the given path. NULL is returned if unable to allocate a mgp_value. </p><h3 id="function-mgp_value_get_type">function mgp_value_get_type</h3><pre><code class="language-cpp">enum mgp_value_type mgp_value_get_type(
    const struct mgp_value * val
)
</code></pre><p>Return the type of the value contained in mgp_value. </p><h3 id="function-mgp_value_is_null">function mgp_value_is_null</h3><pre><code class="language-cpp">int mgp_value_is_null(
    const struct mgp_value * val
)
</code></pre><p>Return non-zero if the given mgp_value represents <code>null</code>. </p><h3 id="function-mgp_value_is_bool">function mgp_value_is_bool</h3><pre><code class="language-cpp">int mgp_value_is_bool(
    const struct mgp_value * val
)
</code></pre><p>Return non-zero if the given mgp_value stores a boolean. </p><h3 id="function-mgp_value_is_int">function mgp_value_is_int</h3><pre><code class="language-cpp">int mgp_value_is_int(
    const struct mgp_value * val
)
</code></pre><p>Return non-zero if the given mgp_value stores an integer. </p><h3 id="function-mgp_value_is_double">function mgp_value_is_double</h3><pre><code class="language-cpp">int mgp_value_is_double(
    const struct mgp_value * val
)
</code></pre><p>Return non-zero if the given mgp_value stores a double floating-point. </p><h3 id="function-mgp_value_is_string">function mgp_value_is_string</h3><pre><code class="language-cpp">int mgp_value_is_string(
    const struct mgp_value * val
)
</code></pre><p>Return non-zero if the given mgp_value stores a character string. </p><h3 id="function-mgp_value_is_list">function mgp_value_is_list</h3><pre><code class="language-cpp">int mgp_value_is_list(
    const struct mgp_value * val
)
</code></pre><p>Return non-zero if the given mgp_value stores a list of values. </p><h3 id="function-mgp_value_is_map">function mgp_value_is_map</h3><pre><code class="language-cpp">int mgp_value_is_map(
    const struct mgp_value * val
)
</code></pre><p>Return non-zero if the given mgp_value stores a map of values. </p><h3 id="function-mgp_value_is_vertex">function mgp_value_is_vertex</h3><pre><code class="language-cpp">int mgp_value_is_vertex(
    const struct mgp_value * val
)
</code></pre><p>Return non-zero if the given mgp_value stores a vertex. </p><h3 id="function-mgp_value_is_edge">function mgp_value_is_edge</h3><pre><code class="language-cpp">int mgp_value_is_edge(
    const struct mgp_value * val
)
</code></pre><p>Return non-zero if the given mgp_value stores an edge. </p><h3 id="function-mgp_value_is_path">function mgp_value_is_path</h3><pre><code class="language-cpp">int mgp_value_is_path(
    const struct mgp_value * val
)
</code></pre><p>Return non-zero if the given mgp_value stores a path. </p><h3 id="function-mgp_value_get_bool">function mgp_value_get_bool</h3><pre><code class="language-cpp">int mgp_value_get_bool(
    const struct mgp_value * val
)
</code></pre><p>Return the contained boolean value.
Non-zero values represent <code>true</code>, while zero represents <code>false</code>. The result is undefined if mgp_value does not contain the expected type. </p><h3 id="function-mgp_value_get_int">function mgp_value_get_int</h3><pre><code class="language-cpp">int64_t mgp_value_get_int(
    const struct mgp_value * val
)
</code></pre><p>Return the contained integer.
The result is undefined if mgp_value does not contain the expected type. </p><h3 id="function-mgp_value_get_double">function mgp_value_get_double</h3><pre><code class="language-cpp">double mgp_value_get_double(
    const struct mgp_value * val
)
</code></pre><p>Return the contained double floating-point.
The result is undefined if mgp_value does not contain the expected type. </p><h3 id="function-mgp_value_get_string">function mgp_value_get_string</h3><pre><code class="language-cpp">const char * mgp_value_get_string(
    const struct mgp_value * val
)
</code></pre><p>Return the contained character string.
The result is undefined if mgp_value does not contain the expected type. </p><h3 id="function-mgp_value_get_list">function mgp_value_get_list</h3><pre><code class="language-cpp">const struct mgp_list * mgp_value_get_list(
    const struct mgp_value * val
)
</code></pre><p>Return the contained list of values.
The result is undefined if mgp_value does not contain the expected type. </p><h3 id="function-mgp_value_get_map">function mgp_value_get_map</h3><pre><code class="language-cpp">const struct mgp_map * mgp_value_get_map(
    const struct mgp_value * val
)
</code></pre><p>Return the contained map of values.
The result is undefined if mgp_value does not contain the expected type. </p><h3 id="function-mgp_value_get_vertex">function mgp_value_get_vertex</h3><pre><code class="language-cpp">const struct mgp_vertex * mgp_value_get_vertex(
    const struct mgp_value * val
)
</code></pre><p>Return the contained vertex.
The result is undefined if mgp_value does not contain the expected type. </p><h3 id="function-mgp_value_get_edge">function mgp_value_get_edge</h3><pre><code class="language-cpp">const struct mgp_edge * mgp_value_get_edge(
    const struct mgp_value * val
)
</code></pre><p>Return the contained edge.
The result is undefined if mgp_value does not contain the expected type. </p><h3 id="function-mgp_value_get_path">function mgp_value_get_path</h3><pre><code class="language-cpp">const struct mgp_path * mgp_value_get_path(
    const struct mgp_value * val
)
</code></pre><p>Return the contained path.
The result is undefined if mgp_value does not contain the expected type. </p><h3 id="function-mgp_list_make_empty">function mgp_list_make_empty</h3><pre><code class="language-cpp">struct mgp_list * mgp_list_make_empty(
    size_t capacity,
    struct mgp_memory * memory
)
</code></pre><p>Create an empty list with given capacity.
You need to free the created instance with mgp_list_destroy. The created list will have allocated enough memory for <code>capacity</code> elements of mgp_value, but it will not contain any elements. Therefore, mgp_list_size will return 0. NULL is returned if unable to allocate a new list. </p><h3 id="function-mgp_list_destroy">function mgp_list_destroy</h3><pre><code class="language-cpp">void mgp_list_destroy(
    struct mgp_list * list
)
</code></pre><p>Free the memory used by the given mgp_list and contained elements. </p><h3 id="function-mgp_list_append">function mgp_list_append</h3><pre><code class="language-cpp">int mgp_list_append(
    struct mgp_list * list,
    const struct mgp_value * val
)
</code></pre><p>Append a copy of mgp_value to mgp_list if capacity allows.
The list copies the given value and therefore does not take ownership of the original value. You still need to call mgp_value_destroy to free the original value. Return non-zero on success, or 0 if there&#x27;s no capacity or memory to append the mgp_value to mgp_list. </p><h3 id="function-mgp_list_append_extend">function mgp_list_append_extend</h3><pre><code class="language-cpp">int mgp_list_append_extend(
    struct mgp_list * list,
    const struct mgp_value * val
)
</code></pre><p>Append a copy of mgp_value to mgp_list increasing capacity if needed.
The list copies the given value and therefore does not take ownership of the original value. You still need to call mgp_value_destroy to free the original value. In case of a capacity change, the previously contained elements will move in memory and any references to them will be invalid. Return non-zero on success, or 0 if there&#x27;s no memory to append the mgp_value to mgp_list. </p><h3 id="function-mgp_list_size">function mgp_list_size</h3><pre><code class="language-cpp">size_t mgp_list_size(
    const struct mgp_list * list
)
</code></pre><p>Return the number of elements stored in mgp_list. </p><h3 id="function-mgp_list_capacity">function mgp_list_capacity</h3><pre><code class="language-cpp">size_t mgp_list_capacity(
    const struct mgp_list * list
)
</code></pre><p>Return the total number of elements for which there&#x27;s already allocated memory in mgp_list. </p><h3 id="function-mgp_list_at">function mgp_list_at</h3><pre><code class="language-cpp">const struct mgp_value * mgp_list_at(
    const struct mgp_list * list,
    size_t index
)
</code></pre><p>Return the element in mgp_list at given position.
NULL is returned if the index is not within mgp_list_size. </p><h3 id="function-mgp_map_make_empty">function mgp_map_make_empty</h3><pre><code class="language-cpp">struct mgp_map * mgp_map_make_empty(
    struct mgp_memory * memory
)
</code></pre><p>Create an empty map of character strings to mgp_value instances.
You need to free the created instance with mgp_map_destroy. NULL is returned if unable to allocate a new map. </p><h3 id="function-mgp_map_destroy">function mgp_map_destroy</h3><pre><code class="language-cpp">void mgp_map_destroy(
    struct mgp_map * map
)
</code></pre><p>Free the memory used by the given mgp_map and contained items. </p><h3 id="function-mgp_map_insert">function mgp_map_insert</h3><pre><code class="language-cpp">int mgp_map_insert(
    struct mgp_map * map,
    const char * key,
    const struct mgp_value * value
)
</code></pre><p>Insert a new mapping from a NULL terminated character string to a value.
If a mapping with the same key already exists, it is <em>not</em> replaced. In case of insertion, both the string and the value are copied into the map. Therefore, the map does not take ownership of the original key nor value, so you still need to free their memory explicitly. Return non-zero on success, or 0 if there&#x27;s no memory to insert a new mapping or a previous mapping already exists. </p><h3 id="function-mgp_map_size">function mgp_map_size</h3><pre><code class="language-cpp">size_t mgp_map_size(
    const struct mgp_map * map
)
</code></pre><p>Return the number of items stored in mgp_map. </p><h3 id="function-mgp_map_at">function mgp_map_at</h3><pre><code class="language-cpp">const struct mgp_value * mgp_map_at(
    const struct mgp_map * map,
    const char * key
)
</code></pre><p>Return the mapped mgp_value to the given character string.
NULL is returned if no mapping exists. </p><h3 id="function-mgp_map_item_key">function mgp_map_item_key</h3><pre><code class="language-cpp">const char * mgp_map_item_key(
    const struct mgp_map_item * item
)
</code></pre><p>Get the key of the mapped item. </p><h3 id="function-mgp_map_item_value">function mgp_map_item_value</h3><pre><code class="language-cpp">const struct mgp_value * mgp_map_item_value(
    const struct mgp_map_item * item
)
</code></pre><p>Get the value of the mapped item. </p><h3 id="function-mgp_map_iter_items">function mgp_map_iter_items</h3><pre><code class="language-cpp">struct mgp_map_items_iterator * mgp_map_iter_items(
    const struct mgp_map * map,
    struct mgp_memory * memory
)
</code></pre><p>Start iterating over items contained in the given map.
The returned mgp_map_items_iterator needs to be deallocated with mgp_map_items_iterator_destroy. NULL is returned if unable to allocate a new iterator. </p><h3 id="function-mgp_map_items_iterator_destroy">function mgp_map_items_iterator_destroy</h3><pre><code class="language-cpp">void mgp_map_items_iterator_destroy(
    struct mgp_map_items_iterator * it
)
</code></pre><p>Deallocate memory used by mgp_map_items_iterator. </p><h3 id="function-mgp_map_items_iterator_get">function mgp_map_items_iterator_get</h3><pre><code class="language-cpp">const struct mgp_map_item * mgp_map_items_iterator_get(
    const struct mgp_map_items_iterator * it
)
</code></pre><p>Get the current item pointed to by the iterator.
When the mgp_map_items_iterator_next is invoked, the returned pointer to mgp_map_item becomes invalid. On the other hand, pointers obtained with mgp_map_item_key and mgp_map_item_value remain valid throughout the lifetime of a map. Therefore, you can store the key as well as the value before, and use them after invoking mgp_map_items_iterator_next. NULL is returned if the end of the iteration has been reached. </p><h3 id="function-mgp_map_items_iterator_next">function mgp_map_items_iterator_next</h3><pre><code class="language-cpp">const struct mgp_map_item * mgp_map_items_iterator_next(
    struct mgp_map_items_iterator * it
)
</code></pre><p>Advance the iterator to the next item stored in map and return it.
The previous pointer obtained through mgp_map_items_iterator_get will be invalidated, but the pointers to key and value will remain valid. NULL is returned if the end of the iteration has been reached. </p><h3 id="function-mgp_path_make_with_start">function mgp_path_make_with_start</h3><pre><code class="language-cpp">struct mgp_path * mgp_path_make_with_start(
    const struct mgp_vertex * vertex,
    struct mgp_memory * memory
)
</code></pre><p>Create a path with the copy of the given starting vertex.
You need to free the created instance with mgp_path_destroy. NULL is returned if unable to allocate a path. </p><h3 id="function-mgp_path_copy">function mgp_path_copy</h3><pre><code class="language-cpp">struct mgp_path * mgp_path_copy(
    const struct mgp_path * path,
    struct mgp_memory * memory
)
</code></pre><p>Copy a mgp_path.
Returned pointer must be freed with mgp_path_destroy. NULL is returned if unable to allocate a mgp_path. </p><h3 id="function-mgp_path_destroy">function mgp_path_destroy</h3><pre><code class="language-cpp">void mgp_path_destroy(
    struct mgp_path * path
)
</code></pre><p>Free the memory used by the given mgp_path and contained vertices and edges. </p><h3 id="function-mgp_path_expand">function mgp_path_expand</h3><pre><code class="language-cpp">int mgp_path_expand(
    struct mgp_path * path,
    const struct mgp_edge * edge
)
</code></pre><p>Append an edge continuing from the last vertex on the path.
The edge is copied into the path. Therefore, the path does not take ownership of the original edge, so you still need to free the edge memory explicitly. The last vertex on the path will become the other endpoint of the given edge, as continued from the current last vertex. Return non-zero on success, or 0 if the current last vertex in the path is not part of the given edge. 0 is also returned if unable to allocate memory for path extension. </p><h3 id="function-mgp_path_size">function mgp_path_size</h3><pre><code class="language-cpp">size_t mgp_path_size(
    const struct mgp_path * path
)
</code></pre><p>Return the number of edges in a mgp_path. </p><h3 id="function-mgp_path_vertex_at">function mgp_path_vertex_at</h3><pre><code class="language-cpp">const struct mgp_vertex * mgp_path_vertex_at(
    const struct mgp_path * path,
    size_t index
)
</code></pre><p>Return the vertex from a path at given index.
The valid index range is [0, mgp_path_size]. NULL is returned if index is out of range. </p><h3 id="function-mgp_path_edge_at">function mgp_path_edge_at</h3><pre><code class="language-cpp">const struct mgp_edge * mgp_path_edge_at(
    const struct mgp_path * path,
    size_t index
)
</code></pre><p>Return the edge from a path at given index.
The valid index range is [0, mgp_path_size - 1]. NULL is returned if index is out of range. </p><h3 id="function-mgp_path_equal">function mgp_path_equal</h3><pre><code class="language-cpp">int mgp_path_equal(
    const struct mgp_path * p1,
    const struct mgp_path * p2
)
</code></pre><p>Return non-zero if given paths are equal, otherwise 0. </p><h3 id="function-mgp_result_set_error_msg">function mgp_result_set_error_msg</h3><pre><code class="language-cpp">int mgp_result_set_error_msg(
    struct mgp_result * res,
    const char * error_msg
)
</code></pre><p>Set the error as the result of the procedure.
If there&#x27;s no memory for copying the error message, 0 is returned. </p><h3 id="function-mgp_result_new_record">function mgp_result_new_record</h3><pre><code class="language-cpp">struct mgp_result_record * mgp_result_new_record(
    struct mgp_result * res
)
</code></pre><p>Create a new record for results.
The previously returned pointer to mgp_result_record is no longer valid, and you must not use it. Return NULL if unable to allocate a mgp_result_record. </p><h3 id="function-mgp_result_record_insert">function mgp_result_record_insert</h3><pre><code class="language-cpp">int mgp_result_record_insert(
    struct mgp_result_record * record,
    const char * field_name,
    const struct mgp_value * val
)
</code></pre><p>Assign a value to a field in the given record.
Return 0 if there&#x27;s no memory to copy the mgp_value to mgp_result_record or if the combination of <code>field_name</code> and <code>val</code> does not satisfy the procedure&#x27;s result signature. </p><h3 id="function-mgp_properties_iterator_destroy">function mgp_properties_iterator_destroy</h3><pre><code class="language-cpp">void mgp_properties_iterator_destroy(
    struct mgp_properties_iterator * it
)
</code></pre><p>Free the memory used by a mgp_properties_iterator. </p><h3 id="function-mgp_properties_iterator_get">function mgp_properties_iterator_get</h3><pre><code class="language-cpp">const struct mgp_property * mgp_properties_iterator_get(
    const struct mgp_properties_iterator * it
)
</code></pre><p>Get the current property pointed to by the iterator.
When the mgp_properties_iterator_next is invoked, the previous mgp_property is invalidated and its value must not be used. NULL is returned if the end of the iteration has been reached. </p><h3 id="function-mgp_properties_iterator_next">function mgp_properties_iterator_next</h3><pre><code class="language-cpp">const struct mgp_property * mgp_properties_iterator_next(
    struct mgp_properties_iterator * it
)
</code></pre><p>Advance the iterator to the next property and return it.
The previous mgp_property obtained through mgp_properties_iterator_get will be invalidated, and you must not use its value. NULL is returned if the end of the iteration has been reached. </p><h3 id="function-mgp_edges_iterator_destroy">function mgp_edges_iterator_destroy</h3><pre><code class="language-cpp">void mgp_edges_iterator_destroy(
    struct mgp_edges_iterator * it
)
</code></pre><p>Free the memory used by a mgp_edges_iterator. </p><h3 id="function-mgp_vertex_get_id">function mgp_vertex_get_id</h3><pre><code class="language-cpp">struct mgp_vertex_id mgp_vertex_get_id(
    const struct mgp_vertex * v
)
</code></pre><p>Get the ID of given vertex.
The ID is only valid for a single query execution, you should never store it globally in a query module. </p><h3 id="function-mgp_vertex_copy">function mgp_vertex_copy</h3><pre><code class="language-cpp">struct mgp_vertex * mgp_vertex_copy(
    const struct mgp_vertex * v,
    struct mgp_memory * memory
)
</code></pre><p>Copy a mgp_vertex.
Returned pointer must be freed with mgp_vertex_destroy. NULL is returned if unable to allocate a mgp_vertex. </p><h3 id="function-mgp_vertex_destroy">function mgp_vertex_destroy</h3><pre><code class="language-cpp">void mgp_vertex_destroy(
    struct mgp_vertex * v
)
</code></pre><p>Free the memory used by a mgp_vertex. </p><h3 id="function-mgp_vertex_equal">function mgp_vertex_equal</h3><pre><code class="language-cpp">int mgp_vertex_equal(
    const struct mgp_vertex * v1,
    const struct mgp_vertex * v2
)
</code></pre><p>Return non-zero if given vertices are equal, otherwise 0. </p><h3 id="function-mgp_vertex_labels_count">function mgp_vertex_labels_count</h3><pre><code class="language-cpp">size_t mgp_vertex_labels_count(
    const struct mgp_vertex * v
)
</code></pre><p>Return the number of labels a given vertex has. </p><h3 id="function-mgp_vertex_label_at">function mgp_vertex_label_at</h3><pre><code class="language-cpp">struct mgp_label mgp_vertex_label_at(
    const struct mgp_vertex * v,
    size_t index
)
</code></pre><p>Return mgp_label in mgp_vertex at given index.
If the index is out of bounds, mgp_label.name is set to NULL. </p><h3 id="function-mgp_vertex_has_label">function mgp_vertex_has_label</h3><pre><code class="language-cpp">int mgp_vertex_has_label(
    const struct mgp_vertex * v,
    struct mgp_label label
)
</code></pre><p>Return non-zero if the given vertex has the given label. </p><h3 id="function-mgp_vertex_has_label_named">function mgp_vertex_has_label_named</h3><pre><code class="language-cpp">int mgp_vertex_has_label_named(
    const struct mgp_vertex * v,
    const char * label_name
)
</code></pre><p>Return non-zero if the given vertex has a label with given name. </p><h3 id="function-mgp_vertex_get_property">function mgp_vertex_get_property</h3><pre><code class="language-cpp">struct mgp_value * mgp_vertex_get_property(
    const struct mgp_vertex * v,
    const char * property_name,
    struct mgp_memory * memory
)
</code></pre><p>Get a copy of a vertex property mapped to a given name.
Returned value must be freed with mgp_value_destroy. NULL is returned if unable to allocate a mgp_value. </p><h3 id="function-mgp_vertex_iter_properties">function mgp_vertex_iter_properties</h3><pre><code class="language-cpp">struct mgp_properties_iterator * mgp_vertex_iter_properties(
    const struct mgp_vertex * v,
    struct mgp_memory * memory
)
</code></pre><p>Start iterating over properties stored in the given vertex.
The returned mgp_properties_iterator needs to be deallocated with mgp_properties_iterator_destroy. NULL is returned if unable to allocate a new iterator. </p><h3 id="function-mgp_vertex_iter_in_edges">function mgp_vertex_iter_in_edges</h3><pre><code class="language-cpp">struct mgp_edges_iterator * mgp_vertex_iter_in_edges(
    const struct mgp_vertex * v,
    struct mgp_memory * memory
)
</code></pre><p>Start iterating over inbound edges of the given vertex.
The returned mgp_edges_iterator needs to be deallocated with mgp_edges_iterator_destroy. NULL is returned if unable to allocate a new iterator. </p><h3 id="function-mgp_vertex_iter_out_edges">function mgp_vertex_iter_out_edges</h3><pre><code class="language-cpp">struct mgp_edges_iterator * mgp_vertex_iter_out_edges(
    const struct mgp_vertex * v,
    struct mgp_memory * memory
)
</code></pre><p>Start iterating over outbound edges of the given vertex.
The returned mgp_edges_iterator needs to be deallocated with mgp_edges_iterator_destroy. NULL is returned if unable to allocate a new iterator. </p><h3 id="function-mgp_edges_iterator_get">function mgp_edges_iterator_get</h3><pre><code class="language-cpp">const struct mgp_edge * mgp_edges_iterator_get(
    const struct mgp_edges_iterator * it
)
</code></pre><p>Get the current edge pointed to by the iterator.
When the mgp_edges_iterator_next is invoked, the previous mgp_edge is invalidated and its value must not be used. NULL is returned if the end of the iteration has been reached. </p><h3 id="function-mgp_edges_iterator_next">function mgp_edges_iterator_next</h3><pre><code class="language-cpp">const struct mgp_edge * mgp_edges_iterator_next(
    struct mgp_edges_iterator * it
)
</code></pre><p>Advance the iterator to the next edge and return it.
The previous mgp_edge obtained through mgp_edges_iterator_get will be invalidated, and you must not use its value. NULL is returned if the end of the iteration has been reached. </p><h3 id="function-mgp_edge_get_id">function mgp_edge_get_id</h3><pre><code class="language-cpp">struct mgp_edge_id mgp_edge_get_id(
    const struct mgp_edge * e
)
</code></pre><p>Get the ID of given edge.
The ID is only valid for a single query execution, you should never store it globally in a query module. </p><h3 id="function-mgp_edge_copy">function mgp_edge_copy</h3><pre><code class="language-cpp">struct mgp_edge * mgp_edge_copy(
    const struct mgp_edge * e,
    struct mgp_memory * memory
)
</code></pre><p>Copy a mgp_edge.
Returned pointer must be freed with mgp_edge_destroy. NULL is returned if unable to allocate a mgp_edge. </p><h3 id="function-mgp_edge_destroy">function mgp_edge_destroy</h3><pre><code class="language-cpp">void mgp_edge_destroy(
    struct mgp_edge * e
)
</code></pre><p>Free the memory used by a mgp_edge. </p><h3 id="function-mgp_edge_equal">function mgp_edge_equal</h3><pre><code class="language-cpp">int mgp_edge_equal(
    const struct mgp_edge * e1,
    const struct mgp_edge * e2
)
</code></pre><p>Return non-zero if given edges are equal, otherwise 0. </p><h3 id="function-mgp_edge_get_type">function mgp_edge_get_type</h3><pre><code class="language-cpp">struct mgp_edge_type mgp_edge_get_type(
    const struct mgp_edge * e
)
</code></pre><p>Return the type of the given edge. </p><h3 id="function-mgp_edge_get_from">function mgp_edge_get_from</h3><pre><code class="language-cpp">const struct mgp_vertex * mgp_edge_get_from(
    const struct mgp_edge * e
)
</code></pre><p>Return the source vertex of the given edge. </p><h3 id="function-mgp_edge_get_to">function mgp_edge_get_to</h3><pre><code class="language-cpp">const struct mgp_vertex * mgp_edge_get_to(
    const struct mgp_edge * e
)
</code></pre><p>Return the destination vertex of the given edge. </p><h3 id="function-mgp_edge_get_property">function mgp_edge_get_property</h3><pre><code class="language-cpp">struct mgp_value * mgp_edge_get_property(
    const struct mgp_edge * e,
    const char * property_name,
    struct mgp_memory * memory
)
</code></pre><p>Get a copy of a edge property mapped to a given name.
Returned value must be freed with mgp_value_destroy. NULL is returned if unable to allocate a mgp_value. </p><h3 id="function-mgp_edge_iter_properties">function mgp_edge_iter_properties</h3><pre><code class="language-cpp">struct mgp_properties_iterator * mgp_edge_iter_properties(
    const struct mgp_edge * e,
    struct mgp_memory * memory
)
</code></pre><p>Start iterating over properties stored in the given edge.
The returned mgp_properties_iterator needs to be deallocated with mgp_properties_iterator_destroy. NULL is returned if unable to allocate a new iterator. </p><h3 id="function-mgp_graph_get_vertex_by_id">function mgp_graph_get_vertex_by_id</h3><pre><code class="language-cpp">struct mgp_vertex * mgp_graph_get_vertex_by_id(
    const struct mgp_graph * g,
    struct mgp_vertex_id id,
    struct mgp_memory * memory
)
</code></pre><p>Return the vertex corresponding to given ID.
The returned vertex must be freed using mgp_vertex_destroy. NULL is returned if unable to allocate the vertex or if ID is not valid. </p><h3 id="function-mgp_vertices_iterator_destroy">function mgp_vertices_iterator_destroy</h3><pre><code class="language-cpp">void mgp_vertices_iterator_destroy(
    struct mgp_vertices_iterator * it
)
</code></pre><p>Free the memory used by a mgp_vertices_iterator. </p><h3 id="function-mgp_graph_iter_vertices">function mgp_graph_iter_vertices</h3><pre><code class="language-cpp">struct mgp_vertices_iterator * mgp_graph_iter_vertices(
    const struct mgp_graph * g,
    struct mgp_memory * memory
)
</code></pre><p>Start iterating over vertices of the given graph.
The returned mgp_vertices_iterator needs to be deallocated with mgp_vertices_iterator_destroy. NULL is returned if unable to allocate a new iterator. </p><h3 id="function-mgp_vertices_iterator_get">function mgp_vertices_iterator_get</h3><pre><code class="language-cpp">const struct mgp_vertex * mgp_vertices_iterator_get(
    const struct mgp_vertices_iterator * it
)
</code></pre><p>Get the current vertex pointed to by the iterator.
When the mgp_vertices_iterator_next is invoked, the previous mgp_vertex is invalidated and its value must not be used. NULL is returned if the end of the iteration has been reached. </p><h3 id="function-mgp_vertices_iterator_next">function mgp_vertices_iterator_next</h3><pre><code class="language-cpp">const struct mgp_vertex * mgp_vertices_iterator_next(
    struct mgp_vertices_iterator * it
)
</code></pre><p>Advance the iterator to the next vertex and return it.
The previous mgp_vertex obtained through mgp_vertices_iterator_get will be invalidated, and you must not use its value. NULL is returned if the end of the iteration has been reached. </p><h3 id="function-mgp_type_any">function mgp_type_any</h3><pre><code class="language-cpp">const struct mgp_type * mgp_type_any()
</code></pre><p>Get the type representing any value that isn&#x27;t <code>null</code>.
The ANY type is the parent type of all types. </p><h3 id="function-mgp_type_bool">function mgp_type_bool</h3><pre><code class="language-cpp">const struct mgp_type * mgp_type_bool()
</code></pre><p>Get the type representing boolean values. </p><h3 id="function-mgp_type_string">function mgp_type_string</h3><pre><code class="language-cpp">const struct mgp_type * mgp_type_string()
</code></pre><p>Get the type representing character string values. </p><h3 id="function-mgp_type_int">function mgp_type_int</h3><pre><code class="language-cpp">const struct mgp_type * mgp_type_int()
</code></pre><p>Get the type representing integer values. </p><h3 id="function-mgp_type_float">function mgp_type_float</h3><pre><code class="language-cpp">const struct mgp_type * mgp_type_float()
</code></pre><p>Get the type representing floating-point values. </p><h3 id="function-mgp_type_number">function mgp_type_number</h3><pre><code class="language-cpp">const struct mgp_type * mgp_type_number()
</code></pre><p>Get the type representing any number value.
This is the parent type for numeric types, i.e. INTEGER and FLOAT. </p><h3 id="function-mgp_type_map">function mgp_type_map</h3><pre><code class="language-cpp">const struct mgp_type * mgp_type_map()
</code></pre><p>Get the type representing map values. </p><p><strong>See</strong>: </p><ul><li><a href="#function-mgp_type_node">mgp_type_node</a></li><li><a href="#function-mgp_type_relationship">mgp_type_relationship</a></li></ul><p>Map values are those which map string keys to values of any type. For example <code>{ database: &quot;Memgraph&quot;, version: 1.42 }</code>. Note that graph nodes contain property maps, so a node value will also satisfy the MAP type. The same applies for graph relationship values.</p><h3 id="function-mgp_type_node">function mgp_type_node</h3><pre><code class="language-cpp">const struct mgp_type * mgp_type_node()
</code></pre><p>Get the type representing graph node values.
Since a node contains a map of properties, the node itself is also of MAP type. </p><h3 id="function-mgp_type_relationship">function mgp_type_relationship</h3><pre><code class="language-cpp">const struct mgp_type * mgp_type_relationship()
</code></pre><p>Get the type representing graph relationship values.
Since a relationship contains a map of properties, the relationship itself is also of MAP type. </p><h3 id="function-mgp_type_path">function mgp_type_path</h3><pre><code class="language-cpp">const struct mgp_type * mgp_type_path()
</code></pre><p>Get the type representing a graph path (walk) from one node to another. </p><h3 id="function-mgp_type_list">function mgp_type_list</h3><pre><code class="language-cpp">const struct mgp_type * mgp_type_list(
    const struct mgp_type * element_type
)
</code></pre><p>Build a type representing a list of values of given <code>element_type</code>.
NULL is returned if unable to allocate the new type. </p><h3 id="function-mgp_type_nullable">function mgp_type_nullable</h3><pre><code class="language-cpp">const struct mgp_type * mgp_type_nullable(
    const struct mgp_type * type
)
</code></pre><p>Build a type representing either a <code>null</code> value or a value of given <code>type</code>.
NULL is returned if unable to allocate the new type. </p><h3 id="function-mgp_module_add_read_procedure">function mgp_module_add_read_procedure</h3><pre><code class="language-cpp">struct mgp_proc * mgp_module_add_read_procedure(
    struct mgp_module * module,
    const char * name,
    mgp_proc_cb cb
)
</code></pre><p>Register a read-only procedure with a module.
The <code>name</code> must be a sequence of digits, underscores, lowercase and uppercase Latin letters. The name must begin with a non-digit character. Note that Unicode characters are not allowed. Additionally, names are case-sensitive.</p><p>NULL is returned if unable to allocate memory for mgp_proc; if <code>name</code> is not valid or a procedure with the same name was already registered. </p><h3 id="function-mgp_proc_add_arg">function mgp_proc_add_arg</h3><pre><code class="language-cpp">int mgp_proc_add_arg(
    struct mgp_proc * proc,
    const char * name,
    const struct mgp_type * type
)
</code></pre><p>Add a required argument to a procedure.
The order of adding arguments will correspond to the order the procedure must receive them through openCypher. Required arguments will be followed by optional arguments.</p><p>The <code>name</code> must be a valid identifier, following the same rules as the procedure<code>name</code> in mgp_module_add_read_procedure.</p><p>Passed in <code>type</code> describes what kind of values can be used as the argument.</p><p>0 is returned if unable to allocate memory for an argument; if invoking this function after setting an optional argument or if <code>name</code> is not valid. Non-zero is returned on success. </p><h3 id="function-mgp_proc_add_opt_arg">function mgp_proc_add_opt_arg</h3><pre><code class="language-cpp">int mgp_proc_add_opt_arg(
    struct mgp_proc * proc,
    const char * name,
    const struct mgp_type * type,
    const struct mgp_value * default_value
)
</code></pre><p>Add an optional argument with a default value to a procedure.
The order of adding arguments will correspond to the order the procedure must receive them through openCypher. Optional arguments must follow the required arguments.</p><p>The <code>name</code> must be a valid identifier, following the same rules as the procedure <code>name</code> in mgp_module_add_read_procedure.</p><p>Passed in <code>type</code> describes what kind of values can be used as the argument.</p><p><code>default_value</code> is copied and set as the default value for the argument. Don&#x27;t forget to call mgp_value_destroy when you are done using <code>default_value</code>. When the procedure is called, if this argument is not provided, <code>default_value</code> will be used instead. <code>default_value</code> must not be a graph element (node, relationship, path) and it must satisfy the given <code>type</code>.</p><p>0 is returned if unable to allocate memory for an argument; if <code>name</code> is not valid or <code>default_value</code> does not satisfy <code>type</code>. Non-zero is returned on success. </p><h3 id="function-mgp_proc_add_result">function mgp_proc_add_result</h3><pre><code class="language-cpp">int mgp_proc_add_result(
    struct mgp_proc * proc,
    const char * name,
    const struct mgp_type * type
)
</code></pre><p>Add a result field to a procedure.
The <code>name</code> must be a valid identifier, following the same rules as the procedure <code>name</code> in mgp_module_add_read_procedure.</p><p>Passed in <code>type</code> describes what kind of values can be returned through the result field.</p><p>0 is returned if unable to allocate memory for a result field; if <code>name</code> is not valid or if a result field with the same name was already added. Non-zero is returned on success. </p><h3 id="function-mgp_proc_add_deprecated_result">function mgp_proc_add_deprecated_result</h3><pre><code class="language-cpp">int mgp_proc_add_deprecated_result(
    struct mgp_proc * proc,
    const char * name,
    const struct mgp_type * type
)
</code></pre><p>Add a result field to a procedure and mark it as deprecated.
This is the same as mgp_proc_add_result, but the result field will be marked as deprecated. </p><h3 id="function-mgp_must_abort">function mgp_must_abort</h3><pre><code class="language-cpp">int mgp_must_abort(
    const struct mgp_graph * graph
)
</code></pre><p>Return non-zero if the currently executing procedure should abort as soon as possible.
Procedures which perform heavyweight processing run the risk of running too long and going over the query execution time limit. To prevent this, such procedures should periodically call this function at critical points in their code in order to determine whether they should abort or not. Note that this mechanism is purely cooperative and depends on the procedure doing the checking and aborting on its own. </p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/memgraph/docs/tree/master/docs/reference-guide/query-modules/c-api.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2LL7"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/memgraph/reference-guide/query-modules"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Query modules</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/memgraph/reference-guide/query-modules/python-api"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Query modules Python API Â»</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_2xL- thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#classes" class="table-of-contents__link">Classes</a></li><li><a href="#types" class="table-of-contents__link">Types</a></li><li><a href="#functions" class="table-of-contents__link">Functions</a></li><li><a href="#types-documentation" class="table-of-contents__link">Types Documentation</a><ul><li><a href="#enum-mgp_value_type" class="table-of-contents__link">enum mgp_value_type</a></li><li><a href="#typedef-mgp_proc_cb" class="table-of-contents__link">typedef mgp_proc_cb</a></li></ul></li><li><a href="#functions-documentation" class="table-of-contents__link">Functions Documentation</a><ul><li><a href="#function-mgp_alloc" class="table-of-contents__link">function mgp_alloc</a></li><li><a href="#function-mgp_aligned_alloc" class="table-of-contents__link">function mgp_aligned_alloc</a></li><li><a href="#function-mgp_free" class="table-of-contents__link">function mgp_free</a></li><li><a href="#function-mgp_value_destroy" class="table-of-contents__link">function mgp_value_destroy</a></li><li><a href="#function-mgp_value_make_null" class="table-of-contents__link">function mgp_value_make_null</a></li><li><a href="#function-mgp_value_make_bool" class="table-of-contents__link">function mgp_value_make_bool</a></li><li><a href="#function-mgp_value_make_int" class="table-of-contents__link">function mgp_value_make_int</a></li><li><a href="#function-mgp_value_make_double" class="table-of-contents__link">function mgp_value_make_double</a></li><li><a href="#function-mgp_value_make_string" class="table-of-contents__link">function mgp_value_make_string</a></li><li><a href="#function-mgp_value_make_list" class="table-of-contents__link">function mgp_value_make_list</a></li><li><a href="#function-mgp_value_make_map" class="table-of-contents__link">function mgp_value_make_map</a></li><li><a href="#function-mgp_value_make_vertex" class="table-of-contents__link">function mgp_value_make_vertex</a></li><li><a href="#function-mgp_value_make_edge" class="table-of-contents__link">function mgp_value_make_edge</a></li><li><a href="#function-mgp_value_make_path" class="table-of-contents__link">function mgp_value_make_path</a></li><li><a href="#function-mgp_value_get_type" class="table-of-contents__link">function mgp_value_get_type</a></li><li><a href="#function-mgp_value_is_null" class="table-of-contents__link">function mgp_value_is_null</a></li><li><a href="#function-mgp_value_is_bool" class="table-of-contents__link">function mgp_value_is_bool</a></li><li><a href="#function-mgp_value_is_int" class="table-of-contents__link">function mgp_value_is_int</a></li><li><a href="#function-mgp_value_is_double" class="table-of-contents__link">function mgp_value_is_double</a></li><li><a href="#function-mgp_value_is_string" class="table-of-contents__link">function mgp_value_is_string</a></li><li><a href="#function-mgp_value_is_list" class="table-of-contents__link">function mgp_value_is_list</a></li><li><a href="#function-mgp_value_is_map" class="table-of-contents__link">function mgp_value_is_map</a></li><li><a href="#function-mgp_value_is_vertex" class="table-of-contents__link">function mgp_value_is_vertex</a></li><li><a href="#function-mgp_value_is_edge" class="table-of-contents__link">function mgp_value_is_edge</a></li><li><a href="#function-mgp_value_is_path" class="table-of-contents__link">function mgp_value_is_path</a></li><li><a href="#function-mgp_value_get_bool" class="table-of-contents__link">function mgp_value_get_bool</a></li><li><a href="#function-mgp_value_get_int" class="table-of-contents__link">function mgp_value_get_int</a></li><li><a href="#function-mgp_value_get_double" class="table-of-contents__link">function mgp_value_get_double</a></li><li><a href="#function-mgp_value_get_string" class="table-of-contents__link">function mgp_value_get_string</a></li><li><a href="#function-mgp_value_get_list" class="table-of-contents__link">function mgp_value_get_list</a></li><li><a href="#function-mgp_value_get_map" class="table-of-contents__link">function mgp_value_get_map</a></li><li><a href="#function-mgp_value_get_vertex" class="table-of-contents__link">function mgp_value_get_vertex</a></li><li><a href="#function-mgp_value_get_edge" class="table-of-contents__link">function mgp_value_get_edge</a></li><li><a href="#function-mgp_value_get_path" class="table-of-contents__link">function mgp_value_get_path</a></li><li><a href="#function-mgp_list_make_empty" class="table-of-contents__link">function mgp_list_make_empty</a></li><li><a href="#function-mgp_list_destroy" class="table-of-contents__link">function mgp_list_destroy</a></li><li><a href="#function-mgp_list_append" class="table-of-contents__link">function mgp_list_append</a></li><li><a href="#function-mgp_list_append_extend" class="table-of-contents__link">function mgp_list_append_extend</a></li><li><a href="#function-mgp_list_size" class="table-of-contents__link">function mgp_list_size</a></li><li><a href="#function-mgp_list_capacity" class="table-of-contents__link">function mgp_list_capacity</a></li><li><a href="#function-mgp_list_at" class="table-of-contents__link">function mgp_list_at</a></li><li><a href="#function-mgp_map_make_empty" class="table-of-contents__link">function mgp_map_make_empty</a></li><li><a href="#function-mgp_map_destroy" class="table-of-contents__link">function mgp_map_destroy</a></li><li><a href="#function-mgp_map_insert" class="table-of-contents__link">function mgp_map_insert</a></li><li><a href="#function-mgp_map_size" class="table-of-contents__link">function mgp_map_size</a></li><li><a href="#function-mgp_map_at" class="table-of-contents__link">function mgp_map_at</a></li><li><a href="#function-mgp_map_item_key" class="table-of-contents__link">function mgp_map_item_key</a></li><li><a href="#function-mgp_map_item_value" class="table-of-contents__link">function mgp_map_item_value</a></li><li><a href="#function-mgp_map_iter_items" class="table-of-contents__link">function mgp_map_iter_items</a></li><li><a href="#function-mgp_map_items_iterator_destroy" class="table-of-contents__link">function mgp_map_items_iterator_destroy</a></li><li><a href="#function-mgp_map_items_iterator_get" class="table-of-contents__link">function mgp_map_items_iterator_get</a></li><li><a href="#function-mgp_map_items_iterator_next" class="table-of-contents__link">function mgp_map_items_iterator_next</a></li><li><a href="#function-mgp_path_make_with_start" class="table-of-contents__link">function mgp_path_make_with_start</a></li><li><a href="#function-mgp_path_copy" class="table-of-contents__link">function mgp_path_copy</a></li><li><a href="#function-mgp_path_destroy" class="table-of-contents__link">function mgp_path_destroy</a></li><li><a href="#function-mgp_path_expand" class="table-of-contents__link">function mgp_path_expand</a></li><li><a href="#function-mgp_path_size" class="table-of-contents__link">function mgp_path_size</a></li><li><a href="#function-mgp_path_vertex_at" class="table-of-contents__link">function mgp_path_vertex_at</a></li><li><a href="#function-mgp_path_edge_at" class="table-of-contents__link">function mgp_path_edge_at</a></li><li><a href="#function-mgp_path_equal" class="table-of-contents__link">function mgp_path_equal</a></li><li><a href="#function-mgp_result_set_error_msg" class="table-of-contents__link">function mgp_result_set_error_msg</a></li><li><a href="#function-mgp_result_new_record" class="table-of-contents__link">function mgp_result_new_record</a></li><li><a href="#function-mgp_result_record_insert" class="table-of-contents__link">function mgp_result_record_insert</a></li><li><a href="#function-mgp_properties_iterator_destroy" class="table-of-contents__link">function mgp_properties_iterator_destroy</a></li><li><a href="#function-mgp_properties_iterator_get" class="table-of-contents__link">function mgp_properties_iterator_get</a></li><li><a href="#function-mgp_properties_iterator_next" class="table-of-contents__link">function mgp_properties_iterator_next</a></li><li><a href="#function-mgp_edges_iterator_destroy" class="table-of-contents__link">function mgp_edges_iterator_destroy</a></li><li><a href="#function-mgp_vertex_get_id" class="table-of-contents__link">function mgp_vertex_get_id</a></li><li><a href="#function-mgp_vertex_copy" class="table-of-contents__link">function mgp_vertex_copy</a></li><li><a href="#function-mgp_vertex_destroy" class="table-of-contents__link">function mgp_vertex_destroy</a></li><li><a href="#function-mgp_vertex_equal" class="table-of-contents__link">function mgp_vertex_equal</a></li><li><a href="#function-mgp_vertex_labels_count" class="table-of-contents__link">function mgp_vertex_labels_count</a></li><li><a href="#function-mgp_vertex_label_at" class="table-of-contents__link">function mgp_vertex_label_at</a></li><li><a href="#function-mgp_vertex_has_label" class="table-of-contents__link">function mgp_vertex_has_label</a></li><li><a href="#function-mgp_vertex_has_label_named" class="table-of-contents__link">function mgp_vertex_has_label_named</a></li><li><a href="#function-mgp_vertex_get_property" class="table-of-contents__link">function mgp_vertex_get_property</a></li><li><a href="#function-mgp_vertex_iter_properties" class="table-of-contents__link">function mgp_vertex_iter_properties</a></li><li><a href="#function-mgp_vertex_iter_in_edges" class="table-of-contents__link">function mgp_vertex_iter_in_edges</a></li><li><a href="#function-mgp_vertex_iter_out_edges" class="table-of-contents__link">function mgp_vertex_iter_out_edges</a></li><li><a href="#function-mgp_edges_iterator_get" class="table-of-contents__link">function mgp_edges_iterator_get</a></li><li><a href="#function-mgp_edges_iterator_next" class="table-of-contents__link">function mgp_edges_iterator_next</a></li><li><a href="#function-mgp_edge_get_id" class="table-of-contents__link">function mgp_edge_get_id</a></li><li><a href="#function-mgp_edge_copy" class="table-of-contents__link">function mgp_edge_copy</a></li><li><a href="#function-mgp_edge_destroy" class="table-of-contents__link">function mgp_edge_destroy</a></li><li><a href="#function-mgp_edge_equal" class="table-of-contents__link">function mgp_edge_equal</a></li><li><a href="#function-mgp_edge_get_type" class="table-of-contents__link">function mgp_edge_get_type</a></li><li><a href="#function-mgp_edge_get_from" class="table-of-contents__link">function mgp_edge_get_from</a></li><li><a href="#function-mgp_edge_get_to" class="table-of-contents__link">function mgp_edge_get_to</a></li><li><a href="#function-mgp_edge_get_property" class="table-of-contents__link">function mgp_edge_get_property</a></li><li><a href="#function-mgp_edge_iter_properties" class="table-of-contents__link">function mgp_edge_iter_properties</a></li><li><a href="#function-mgp_graph_get_vertex_by_id" class="table-of-contents__link">function mgp_graph_get_vertex_by_id</a></li><li><a href="#function-mgp_vertices_iterator_destroy" class="table-of-contents__link">function mgp_vertices_iterator_destroy</a></li><li><a href="#function-mgp_graph_iter_vertices" class="table-of-contents__link">function mgp_graph_iter_vertices</a></li><li><a href="#function-mgp_vertices_iterator_get" class="table-of-contents__link">function mgp_vertices_iterator_get</a></li><li><a href="#function-mgp_vertices_iterator_next" class="table-of-contents__link">function mgp_vertices_iterator_next</a></li><li><a href="#function-mgp_type_any" class="table-of-contents__link">function mgp_type_any</a></li><li><a href="#function-mgp_type_bool" class="table-of-contents__link">function mgp_type_bool</a></li><li><a href="#function-mgp_type_string" class="table-of-contents__link">function mgp_type_string</a></li><li><a href="#function-mgp_type_int" class="table-of-contents__link">function mgp_type_int</a></li><li><a href="#function-mgp_type_float" class="table-of-contents__link">function mgp_type_float</a></li><li><a href="#function-mgp_type_number" class="table-of-contents__link">function mgp_type_number</a></li><li><a href="#function-mgp_type_map" class="table-of-contents__link">function mgp_type_map</a></li><li><a href="#function-mgp_type_node" class="table-of-contents__link">function mgp_type_node</a></li><li><a href="#function-mgp_type_relationship" class="table-of-contents__link">function mgp_type_relationship</a></li><li><a href="#function-mgp_type_path" class="table-of-contents__link">function mgp_type_path</a></li><li><a href="#function-mgp_type_list" class="table-of-contents__link">function mgp_type_list</a></li><li><a href="#function-mgp_type_nullable" class="table-of-contents__link">function mgp_type_nullable</a></li><li><a href="#function-mgp_module_add_read_procedure" class="table-of-contents__link">function mgp_module_add_read_procedure</a></li><li><a href="#function-mgp_proc_add_arg" class="table-of-contents__link">function mgp_proc_add_arg</a></li><li><a href="#function-mgp_proc_add_opt_arg" class="table-of-contents__link">function mgp_proc_add_opt_arg</a></li><li><a href="#function-mgp_proc_add_result" class="table-of-contents__link">function mgp_proc_add_result</a></li><li><a href="#function-mgp_proc_add_deprecated_result" class="table-of-contents__link">function mgp_proc_add_deprecated_result</a></li><li><a href="#function-mgp_must_abort" class="table-of-contents__link">function mgp_must_abort</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Documentation</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/memgraph/overview">Memgraph DB</a></li><li class="footer__item"><a class="footer__link-item" href="/memgraph-lab">Memgraph Lab</a></li><li class="footer__item"><a class="footer__link-item" href="/memgraph-cloud">Memgraph Cloud</a></li><li class="footer__item"><a class="footer__link-item" href="/cypher-manual">Cypher manual</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/memgraphdb" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow</a></li><li class="footer__item"><a href="https://discourse.memgraph.com" target="_blank" rel="noopener noreferrer" class="footer__link-item">Developer Forum</a></li><li class="footer__item"><a href="https://twitter.com/memgraphdb" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a href="https://github.com/memgraph" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li><li class="footer__item"><a href="https://www.youtube.com/channel/UCZ3HOJvHGxtQ_JHxOselBYg" target="_blank" rel="noopener noreferrer" class="footer__link-item">Youtube</a></li></ul></div></div><div class="footer__bottom text--center"><div class="margin-bottom--sm"><a href="https://memgraph.com" target="_blank" rel="noopener noreferrer" class="footerLogoLink_31Aa"><img class="footer__logo" alt="Memgraph Logo" src="/img/Memgraph-logo-white-rgb.png"></a></div><div class="footer__copyright">Copyright Â© 2021 Memgraph. Built by developers, for developers!</div></div></div></footer></div>
<script src="/styles.59fcf1e7.js"></script>
<script src="/runtime~main.9d2c059a.js"></script>
<script src="/main.79262d0f.js"></script>
<script src="/1.87301906.js"></script>
<script src="/2.51806c2b.js"></script>
<script src="/105.007cf896.js"></script>
<script src="/108.8571e3f8.js"></script>
<script src="/935f2afb.0f6a0534.js"></script>
<script src="/17896441.83e9fdd2.js"></script>
<script src="/7974d505.9065b331.js"></script>
</body>
</html>